package astFileProcessor.processors.cyclomaticComplexity;

import java.io.IOException;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import astFileProcessor.annotationManagment.astConstructs.NotFoundBlockElementToWrap;
import astFileProcessor.astObjects.cyclomaticComplexity.ASTConditionalStatement;
import astFileProcessor.processors.ASTTextExtractorTools;
import unsupportedDecoratorsManagement.NonExistingDecoratorTransformationType;
import unsupportedDecoratorsManagement.entities.IllegalImportNameSpecifiedException;


public class ASTCyclomaticTransformationProcessor {

	private ExpressionsForCyclomaticComplexityManipulationSettings expressionsForCyclomaticComplexityManipulationSettings;
	
	
	public ASTCyclomaticTransformationProcessor() {
	}
	
	public void transformVariabilityAnnotations(JSONObject astRoot, 
			ExpressionsForCyclomaticComplexityManipulationSettings expressionsForCyclomaticComplexityManipulationSettings) 
			throws NonExistingDecoratorTransformationType, IOException, InterruptedException, 
			       IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		this.expressionsForCyclomaticComplexityManipulationSettings = expressionsForCyclomaticComplexityManipulationSettings;
		this.transformVariabilityAnnotations(astRoot, astRoot, astRoot, astRoot);
		this.removeVariabilityAnnotations(astRoot, astRoot);
	}
	
	private void transformAccordingToFoundVariabilityAnnotation(JSONObject astElement, JSONObject astParent, JSONObject astGrandParent, JSONObject astRoot) throws IOException, InterruptedException, ParseException {
		String decoratorName = "";
		if (astElement.containsKey("modifiers")) {
			if (astParent.containsKey("members") && astParent.containsKey("statements")) {
				this.handleClassVariabilityAnnotation(astElement, astParent, astRoot);
			} else if (astParent.containsKey("body") && astParent.containsKey("parameters")) {
				this.handleMethodVariabilityAnnotation(astElement, astParent, astRoot);
			} else if (astGrandParent.containsKey("body") && astGrandParent.containsKey("parameters")) {
				this.handleMethodParameterVariabilityAnnotation(astElement, astParent, astRoot);
			}
		}
	}
	
	private void handleMethodVariabilityAnnotation(JSONObject astElement, JSONObject astParent, JSONObject astRoot) throws IOException, InterruptedException {
		boolean shouldTransform = false;
		String decoratorName = "";
		JSONObject decoratorElement = null;
		int foundPosition = 0;
		for (Object decoratorElementObject: (JSONArray) astElement.get("modifiers")) {
			decoratorElement = (JSONObject) decoratorElementObject;
			decoratorName = ASTTextExtractorTools.getTextFromAstIncludingNameAndExpressions(decoratorElement);
			if (this.expressionsForCyclomaticComplexityManipulationSettings.canBeProcessed(decoratorName, false, true)) {
				shouldTransform = true;
			}
			foundPosition = foundPosition + 1;
		}
		
		
	}
	
	private void handleMethodParameterVariabilityAnnotation(JSONObject astElement, JSONObject astParent, JSONObject astRoot) throws IOException, InterruptedException, ParseException {
		boolean shouldTransform = false;
		String decoratorName = "";
		JSONObject decoratorElement = null;
		for (Object decoratorElementObject: (JSONArray) astElement.get("modifiers")) {
			decoratorElement = (JSONObject) decoratorElementObject;
			decoratorName = ASTTextExtractorTools.getTextFromAstIncludingNameAndExpressions(decoratorElement);
			if (this.expressionsForCyclomaticComplexityManipulationSettings.canBeProcessed(decoratorName, false, true)) {
				shouldTransform = true;
			}
		}
		
		JSONArray methodStatements;
		JSONObject innnerConfigurationExpressionAst;
		JSONObject methodBody = (JSONObject) astElement.get("body");
		if (shouldTransform && methodBody != null) {
			methodStatements = (JSONArray) methodBody.get("statements");
			if (methodStatements != null) {
				innnerConfigurationExpressionAst = ASTTextExtractorTools.extractExpressionFromDecoratorAsAst(
						decoratorElement, 0);
				String astObjectString = ASTConditionalStatement.getAstConditionalExpressionStatement(
						innnerConfigurationExpressionAst.get("properties").toString(), decoratorName, 
						methodStatements);
				methodBody.put("statements", (JSONObject) new JSONParser().parse(astObjectString));
				System.out.println("Done");
			} else {
				System.out.println("Cannot find statements in method's body!");
			}
		} else {
			System.out.println("Cannot find method body!");
		}
	}
	
	private void handleClassVariabilityAnnotation(JSONObject astElement, JSONObject astParent, JSONObject astRoot) throws IOException, InterruptedException, ParseException {
		boolean shouldTransform = false;
		String decoratorName = "";
		JSONObject decoratorElement = null;
		int foundPosition = 0;
		for (Object decoratorElementObject: (JSONArray) astElement.get("modifiers")) {
			decoratorElement = (JSONObject) decoratorElementObject;
			decoratorName = ASTTextExtractorTools.getTextFromAstIncludingNameAndExpressions(decoratorElement);
			if (this.expressionsForCyclomaticComplexityManipulationSettings.canBeProcessed(decoratorName, false, true)) {
				shouldTransform = true;
			}
			foundPosition = foundPosition + 1;
		}
		
		if (shouldTransform) {
			JSONArray statementsArray = (JSONArray) astParent.get("statements");
			JSONObject statementAST;
			String statementName;
			String observedStatementName = (String) ((JSONObject) astElement.get("name")).get("escapedText");
			JSONObject innerConfigurationExpressionAst;
			int place = 0;
			for (Object statement: statementsArray) {
				statementAST = (JSONObject) statement;
				JSONObject nameObject = (JSONObject) statementAST.get("name");
				if (nameObject != null) {
					statementName = (String) nameObject.get("escapedText");
				} else {
					statementName = null;
				}
				System.out.println(observedStatementName + " <---> " + statementName);
				if (statementName != null && statementName.equals(observedStatementName)) {
					innerConfigurationExpressionAst = ASTTextExtractorTools.extractExpressionFromDecoratorAsAst(
							decoratorElement, 0);
					String astObjectString = ASTConditionalStatement.getAstConditionalExpressionStatement(
							innerConfigurationExpressionAst.get("properties").toString(), decoratorName, 
							statementAST.toString());
					if (!statementsArray.remove(statement)) {
						System.out.println("Unsuccessful removal.");
						if (!statementsArray.remove(statementAST)) {
							System.out.println("Unsuccessful removal 2.");
						}
					}
					System.out.println("Extensions:.....");
					System.out.println(decoratorElement.toString());
					System.out.println("Extensions:.....");
					System.out.println(astObjectString);
					statementsArray.add(place, (JSONObject) new JSONParser().parse(astObjectString));
					System.out.println(astRoot.toString());
					///ASTConverterClient.convertFromASTToCode(observedStatementName)
					break; 
				}
				place = place + 1;
			}

		}
	}
	
	private void transformVariabilityAnnotations(JSONObject astElement, JSONObject astParent, JSONObject astGrandParent, JSONObject astRoot) throws IOException, InterruptedException, ParseException {
		String key;
		if (astElement == null) { return; }
		this.transformAccordingToFoundVariabilityAnnotation(astElement, astParent, astGrandParent, astRoot);
		
		
		Object entryValue;
		JSONObject entryJSONObject;
		JSONArray contextArray;
		for(Object entryKey: astElement.keySet()) {
			key = (String) entryKey;
			entryValue = astElement.get(key);
			//if (key.equals("illegalDecorators")) {	continue; }
			if (entryValue instanceof JSONObject) {
				entryJSONObject = (JSONObject) entryValue;
				this.transformVariabilityAnnotations(entryJSONObject, astElement, astParent, astRoot);
			} else if(entryValue instanceof JSONArray) {	
				contextArray = (JSONArray) entryValue;
				
				if (key.equals("modifiers")) { return; }
				for (int index = 0; index < contextArray.size(); index++) {
					entryJSONObject = (JSONObject) contextArray.get(index);
	
					this.transformVariabilityAnnotations(entryJSONObject, astElement, astParent, astRoot);
				}
			}
		}
	}
	
	private void removeVariabilityAnnotation(JSONObject astElement) {
			
	}
	
	private void removeVariabilityAnnotations(JSONObject astElement, JSONObject astParent) throws IOException, InterruptedException, ParseException {
		String key;
		if (astElement == null) { return; }
		this.removeVariabilityAnnotation(astElement); 
		
		Object entryValue;
		JSONObject entryJSONObject;
		JSONArray contextArray;
		for(Object entryKey: astElement.keySet()) {
			key = (String) entryKey;
			entryValue = astElement.get(key);
			//if (key.equals("illegalDecorators")) {	continue; }
			if (entryValue instanceof JSONObject) {
				entryJSONObject = (JSONObject) entryValue;
				this.removeVariabilityAnnotations(entryJSONObject, astElement);
			} else if(entryValue instanceof JSONArray) {	
				contextArray = (JSONArray) entryValue;
				
				for (int index = 0; index < contextArray.size(); index++) {
					entryJSONObject = (JSONObject) contextArray.get(index);
	
					this.removeVariabilityAnnotations(entryJSONObject, astElement);
				}
			}
		}
	}
}
