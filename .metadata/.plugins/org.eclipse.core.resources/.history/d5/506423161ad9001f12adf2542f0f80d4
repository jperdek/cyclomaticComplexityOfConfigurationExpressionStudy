package scenarios.cyclomaticComplexityEvaluation;

import java.io.IOException;

import org.json.simple.parser.ParseException;

import SPLComplexityEvaluation.SPLDecoratorComplexityComparator;
import astFileProcessor.annotationManagment.astConstructs.NotFoundBlockElementToWrap;
import astFileProcessor.processors.cyclomaticComplexity.ExpressionsForCyclomaticComplexityManipulationSettings;
import astFileProcessor.processors.cyclomaticComplexity.configurationExpressions.types.ConfigurationExpressionAsLayersAsJSON;
import astFileProcessor.processors.cyclomaticComplexity.configurationExpressions.types.CustomConfigurationExpressionAsJSON;
import astFileProcessor.processors.cyclomaticComplexity.configurationExpressions.types.EntireConfigurationExpressionAsJSON;
import astFileProcessor.processors.cyclomaticComplexity.configurationExpressions.types.NativeConfigurationExpression;
import scenarios.Scenario;
import unsupportedDecoratorsManagement.NonExistingDecoratorTransformationType;
import unsupportedDecoratorsManagement.entities.IllegalImportNameSpecifiedException;


public class TransformationFormsForCyclomaticComplexity {

	public TransformationFormsForCyclomaticComplexity() {	
	}
	
	public static ExpressionsForCyclomaticComplexityManipulationSettings getConditionalFlowWithEntireHierarchicExpression(boolean useReducedForm) {
		ExpressionsForCyclomaticComplexityManipulationSettings exprForCyclomaticComplManipSettings 
			= ExpressionsForCyclomaticComplexityManipulationSettings.getSettingsForEntireConfigurationExpressionAsJSON();
		exprForCyclomaticComplManipSettings.setWholeFileContentToBeStoredOption(true);
		exprForCyclomaticComplManipSettings.allowOnlyDefaultOnes();
		exprForCyclomaticComplManipSettings.allowOnlyUsedAngularOnes();
		exprForCyclomaticComplManipSettings.setReducedFormInJSONExpressions(useReducedForm);
		exprForCyclomaticComplManipSettings.setConfigurationExpressionType(new EntireConfigurationExpressionAsJSON(exprForCyclomaticComplManipSettings));
		return exprForCyclomaticComplManipSettings;
	}
	
	public static ExpressionsForCyclomaticComplexityManipulationSettings getConditionalFlowWithNativeConditions() {
		ExpressionsForCyclomaticComplexityManipulationSettings exprForCyclomaticComplManipSettings 
			= ExpressionsForCyclomaticComplexityManipulationSettings.getSettingsForNativeConfigurationExpressions();
		exprForCyclomaticComplManipSettings.setWholeFileContentToBeStoredOption(true);
		exprForCyclomaticComplManipSettings.allowOnlyDefaultOnes();
		exprForCyclomaticComplManipSettings.allowOnlyUsedAngularOnes();
		exprForCyclomaticComplManipSettings.setConfigurationExpressionType(new NativeConfigurationExpression());
		return exprForCyclomaticComplManipSettings;
	}
	
	public static ExpressionsForCyclomaticComplexityManipulationSettings getConditionalFlowWithLayeredConditions(boolean useReducedForm) {
		ExpressionsForCyclomaticComplexityManipulationSettings exprForCyclomaticComplManipSettings 
			= ExpressionsForCyclomaticComplexityManipulationSettings.getSettingsForConfigurationExpressionsEvaluatedAsLayers();
		exprForCyclomaticComplManipSettings.setWholeFileContentToBeStoredOption(true);
		exprForCyclomaticComplManipSettings.allowOnlyDefaultOnes();
		exprForCyclomaticComplManipSettings.allowOnlyUsedAngularOnes();
		exprForCyclomaticComplManipSettings.setReducedFormInJSONExpressions(useReducedForm);
		exprForCyclomaticComplManipSettings.setConfigurationExpressionType(new ConfigurationExpressionAsLayersAsJSON(exprForCyclomaticComplManipSettings));
		return exprForCyclomaticComplManipSettings;
	}
	
	public static ExpressionsForCyclomaticComplexityManipulationSettings getConditionalFlowWithCustomConditions(boolean useReducedForm) {
		ExpressionsForCyclomaticComplexityManipulationSettings exprForCyclomaticComplManipSettings 
			= ExpressionsForCyclomaticComplexityManipulationSettings.getSettingsForConfigurationExpressionsEvaluatedAsLayers();
		exprForCyclomaticComplManipSettings.setWholeFileContentToBeStoredOption(true);
		exprForCyclomaticComplManipSettings.allowOnlyDefaultOnes();
		exprForCyclomaticComplManipSettings.allowOnlyUsedAngularOnes();
		exprForCyclomaticComplManipSettings.setReducedFormInJSONExpressions(useReducedForm);
		exprForCyclomaticComplManipSettings.setConfigurationExpressionType(new CustomConfigurationExpressionAsJSON(exprForCyclomaticComplManipSettings));
		return exprForCyclomaticComplManipSettings;
	}
	
	public static void evaluateCyclomaticComplexityForm1() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		SPLDecoratorComplexityComparator splDecoratorComparator = Scenario.getDefaultCyclomaticComplexityComparator();
		ExpressionsForCyclomaticComplexityManipulationSettings cyclomaticComplexityManipulationSettings = 
				TransformationFormsForCyclomaticComplexity.getConditionalFlowWithNativeConditions();
		splDecoratorComparator.evaluateComplexitiesOfAllForms("CYCLFORM1", cyclomaticComplexityManipulationSettings);
	}
	
	public static void evaluateCyclomaticComplexityForm2() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		SPLDecoratorComplexityComparator splDecoratorComparator = Scenario.getDefaultCyclomaticComplexityComparator();
		ExpressionsForCyclomaticComplexityManipulationSettings cyclomaticComplexityManipulationSettings = 
				TransformationFormsForCyclomaticComplexity.getConditionalFlowWithEntireHierarchicExpression(true);
		splDecoratorComparator.evaluateComplexitiesOfAllForms("CYCLFORM2", cyclomaticComplexityManipulationSettings);
	}
	
	public static void evaluateCyclomaticComplexityForm3() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		SPLDecoratorComplexityComparator splDecoratorComparator = Scenario.getDefaultCyclomaticComplexityComparator();
		ExpressionsForCyclomaticComplexityManipulationSettings cyclomaticComplexityManipulationSettings = 
				TransformationFormsForCyclomaticComplexity.getConditionalFlowWithLayeredConditions(true);
		splDecoratorComparator.evaluateComplexitiesOfAllForms("CYCLFORM3", cyclomaticComplexityManipulationSettings);
	}
	
	public static void evaluateCyclomaticComplexityForm4() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		SPLDecoratorComplexityComparator splDecoratorComparator = Scenario.getDefaultCyclomaticComplexityComparator();
		ExpressionsForCyclomaticComplexityManipulationSettings cyclomaticComplexityManipulationSettings = 
				TransformationFormsForCyclomaticComplexity.getConditionalFlowWithCustomConditions(true);
		splDecoratorComparator.evaluateComplexitiesOfAllForms("CYCLFORM4", cyclomaticComplexityManipulationSettings);
	}
	
	
	public static void evaluateCyclomaticComplexityForm2Extended() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		SPLDecoratorComplexityComparator splDecoratorComparator = Scenario.getDefaultCyclomaticComplexityComparator();
		ExpressionsForCyclomaticComplexityManipulationSettings cyclomaticComplexityManipulationSettings = 
				TransformationFormsForCyclomaticComplexity.getConditionalFlowWithEntireHierarchicExpression(false);
		splDecoratorComparator.evaluateComplexitiesOfAllForms("CYCLFORM2EXT", cyclomaticComplexityManipulationSettings);
	}
	
	public static void evaluateCyclomaticComplexityForm3Extendend() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		SPLDecoratorComplexityComparator splDecoratorComparator = Scenario.getDefaultCyclomaticComplexityComparator();
		ExpressionsForCyclomaticComplexityManipulationSettings cyclomaticComplexityManipulationSettings = 
				TransformationFormsForCyclomaticComplexity.getConditionalFlowWithLayeredConditions(false);
		splDecoratorComparator.evaluateComplexitiesOfAllForms("CYCLFORM3EXT", cyclomaticComplexityManipulationSettings);
	}
	
	public static void evaluateCyclomaticComplexityForm4Extended() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		SPLDecoratorComplexityComparator splDecoratorComparator = Scenario.getDefaultCyclomaticComplexityComparator();
		ExpressionsForCyclomaticComplexityManipulationSettings cyclomaticComplexityManipulationSettings = 
				TransformationFormsForCyclomaticComplexity.getConditionalFlowWithCustomConditions(false);
		splDecoratorComparator.evaluateComplexitiesOfAllForms("CYCLFORM4EXT", cyclomaticComplexityManipulationSettings);
	}
	
	public static void evaluateAllForms() throws NonExistingDecoratorTransformationType, IOException, IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		//TransformationFormsForCyclomaticComplexity.evaluateCyclomaticComplexityForm1();
		//TransformationFormsForCyclomaticComplexity.evaluateCyclomaticComplexityForm2();
		//TransformationFormsForCyclomaticComplexity.evaluateCyclomaticComplexityForm3();
		TransformationFormsForCyclomaticComplexity.evaluateCyclomaticComplexityForm4();
		//TransformationFormsForCyclomaticComplexity.evaluateCyclomaticComplexityForm2Extended();
		//TransformationFormsForCyclomaticComplexity.evaluateCyclomaticComplexityForm3Extende();
		//TransformationFormsForCyclomaticComplexity.evaluateCyclomaticComplexityForm4Extended();
	}

	public static void main(String args[]) throws NonExistingDecoratorTransformationType, IOException, 
		IllegalImportNameSpecifiedException, NotFoundBlockElementToWrap, ParseException {
		TransformationFormsForCyclomaticComplexity.evaluateAllForms();
	}
}
